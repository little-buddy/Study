# Tree 树

## 树的定义
> 在树中常常将数据元素称为 结点
  树 (tree) 是n(>=0个)结点的有限集合,当n=0时，称为空树。
  一棵非空树满足以下条件：
> *  有且仅有一个特定的称为根 的结点
> *  n > 1 时，除了根节点之外的 其余结点被分成m个互不相交的有限集合T1、T2...Tn，其中每个集合又是一棵树，并称为这个根节点的子树
	显示。树的定义是递归的

## 树的基本术语
> 结点的度	某结点拥有的子树个数称为结点的度
  树的度     树种各结点的度最大值称为树v的度   二叉树的度为2
  叶子结点   度为0的结点称为叶子结点，子树为NULL
  分支结点	度不为0的结点称为分支结点
  孩子结点	某结点的子树的根节点称为该结点的孩子结点
  双亲结点	某子树的根节点的父结点 称为该子树的双亲结点
  兄弟结点	同一个双亲结点的孩子结点互称为兄弟结点
  路径		一个n1、n2...nk 的结点序列 满足 n(i)是n(i+1)的双亲结点，
  			则称n1-nk的路径，路径上经过的边数称为路径长度[ 长度比结点个数少1，变相看成 忽略树的根节点 ]
  祖先、孙子		如果从结点x 到 结点y，存在一条路径，那么 x就称为y的祖先，y称为x的孙子
  结点的层数  固定根节点的层数为1，某节点在k层，则孩子节点在 k+1 层
  树的深度    树种所有结点的最大层数称为树的深度
  层序编号    将树中的结点 按照 从上层到下层，同层从左至右的次序依次给它们编以1开始的连续自然数。树的这种编号方式称为层序编号
  有序树、无序树		树种的各结点的子树从左到右是有次序的。即若交互了各子树相对应的位置，构成不同的树【有序数】，否则【无序树】
  		无特殊说明，数据结构中一般讨论有序数。  【 那无序树是否一定是对称的呢？】
  森林		m（m>=0）棵，互不相交的树的集合构成森林。任何一棵树删除根结点 就成了森林

##### 树的遍历操作、还是比较难的。需要使用 递归 或者 循环 的操作方式
  * 前序遍历：
>* 访问根结点
* 按照从左到右的顺序前序遍历根结点的每一刻子树

  * 后序遍历（从左下角开始的）
> * 按照从左到右的顺序遍历根结点的每一棵子树
> * 访问根结点

  * 层序遍历（中序遍历）
> 层序遍历亦称为树的广度遍历，从树的第一层（即根结点）开始，自上而下层序遍历，在同一层中，按从左到右的顺序对结点逐个访问

## 树的存储结构
* 双亲表示法
>    书里面是用一个数组去存，然后是 data+parent(数组下标) 的形式去处理
>    无法反应兄弟结点之间的关系，并且无法通过某节点获取该结点的孩子结点


* 孩子表示法  
> 多重链表表示法
> 孩子链表表示法

* 双亲孩子表示法
* 孩子兄弟表示法

## 二叉树的逻辑结构（大部分是对于二叉树的）
> 二叉树是一个简单的树结构，特别适合计算机处理。而且任何树都可以简单地转换成二叉树
  用了兄弟孩子表示法，将任意树抽象成了一个二叉树，兄弟孩子法是能唯一表示一棵树的，则这个抽象出来的二叉树就是这棵树的另一表现形式

## 二叉树的定义 binary tree
> n(n>=0)个结点的有限集合，该集合或者为空集，或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成
##### 特点：
> * 每个结点必然最多只有2棵子树，所以二叉树中不存在度大于2的结点
> * 二叉树是有序的，其次序不能任意颠倒。即使树中的某个结点只有1棵子树，也要区分它是左子树还是右子树
所以 二叉树 和 树 是2 种树结构，树不就是二叉树的超集吗？含有更多的特点

##### 二叉树的5种形态： 
* 空树
* 只有一个根结点
* 左子树
* 右子树
* 左右子树

##### 常用二叉树：
> * 斜树（所有结点都在左子树上或者都在右子树上）
> * 满二叉树 所有分支结点都存在左子树和右子树，并且叶子结点都在同一层上【特点：叶子结点只能存在最下层。只有度为0和度为2的结点】
> * 完全二叉树 对具有n个结点的二叉树按层序编号，如果编号为I的结点与同样深度的满二叉树中编号为I的结点在二叉树中的位置完全相同
>   特点： 
>> * 叶子结点只能出现在最下面两层，且最下面的叶子结点都集中在树的左侧连续位置
>> * 如果有度为1的结点只可能有一个，且该结点只有左子树

	树 -> 二叉树 -> 完全二叉树。逐渐细分到一个常用领域去使用

##### 二叉树的基本性质

* 二叉树的第i层上最多有2^(i-1) 个结点（i>=1） [ 书上给了一个归纳法证明 ]
* 在一棵深度为k的二叉树中，最多有2^k -1个结点，至少有 k个结点 [ 最多就是满二叉树情况，最少就是斜树情况  ]
* 在一颗二叉树中，如果叶子结点的个数为n0，度为2的叶子结点个数为 n2，则有 n0 = n2 + 1
* 具有n个结点的完全二叉树的深度为 [ log2(n) ] +1  【 注：这里的 [ ] 是取整的意思 】 Math.floor 的意思
* 对一颗具有 N 个结点的完全二叉树的结点从1开始按层序编号，则对于任意的编号为i（1<=i<=n）的结点有

>> * 如果 i > 1,则有结点i的双亲编号为 i/2，否则结点 i 是 根结点，无双亲
>> * 如果 2i<=n,则结点i的左孩子的编号为2i，否则结点i无左孩子
>> * 如果 2i+1<=n,则结点 I 的右孩子的编号为 2i+1，否则结点i无右孩子
【 归纳法证明 】
	因为正常情况下，上下层成2倍的关系，所以以上3个关系是一定的，至于有没有用就另说了

#### 二叉树的遍历操作
* 前序遍历
 访问根结点
 前序遍历根结点的左子树
 前序遍历根结点的右子树
* 后续遍历
 后序遍历根结点的左子树
 后序遍历根结点的右子树
 访问根结点
* 中序遍历
 中序遍历根结点的左子树
 访问根结点
 中序遍历根结点的右子树
* 层序遍历
 按层序编号，依次遍历

#### 二叉树的存储结构及实现
* 顺序存储结构
 用一维数组存储一棵二叉树，将二叉树用 null 结点 填补成一棵满二叉树。
 这种方式过于浪费空间，对于斜树的处理效率低下，比较适合用于存储满二叉树
* 二叉链表
 | lchild | data | rchild |
* 三叉链表
 | lchild | data | rchild | parent
* 线索链表
 | ltag | lchild | data | rchild | rtag |
  指向前驱和后继结点的指针称为线索，则加上线索的二叉树称为线索二叉树，加上线索的二叉链表称为线索链表
  由于二叉链表对于空指针域存在内存浪费，线索链表为此而生，用空指针域去存储前驱后继或者孩子结点
  因此 又用 ltag 与 rtag 去区分 是前驱后继 还是 孩子结点。0 指向孩子，1 指向该结点的前驱(l)、后继(r)

#### 树、森林与二叉树的转换
1、树 -> 二叉树
  加线：在相邻的兄弟结点之间加一个线
  去线：只保留每个结点的第一个孩子结点的那根线，其余去掉
  层次调整：礼貌性步骤
  树的前序遍历 依旧是 二叉树的前序遍历
  树的后续遍历  --->  二叉树的中序遍历 【神奇】
2、森林 -> 二叉树
  将森林中的每棵树转换成二叉树
  从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树根结点的右孩子
3、二叉树 -> 树 或 森林
  树转换成二叉树，其根结点无右子树
  而 森林转换成二叉树，其根结点有右子树
  所以根据 是否存在右子树来决定将二叉树转成树还是森林

  加线：如果某结点是其父节点的左孩子，则将该结点的右孩子、以及右孩子的右孩子。。。都与 其父节点相连
  去线：删除原二叉树中所有的双亲结点与其右孩子的连线
  层次调整：礼貌性行为

  【森林的遍历】 挨个对数进行遍历，由于每棵树不一定都存在2个孩子，所以只包含了 前序遍历、后序遍历

个人觉得转换的意义就是，二叉树便于遍历，可理解，且具有唯一遍历序列(层序)

#### 哈弗曼树 huffman tree
  哈弗曼树也称最优二叉树，在实际中有着广泛的应用

  叶子结点的权值
    叶子结点的权值是对叶子结点赋予的一个有意义的数值量 【 在结点赋值 】，我考虑的时在路径上赋值
  二叉树的带权路径长度 [ weighted path length ]
    设 二叉树具有n个带权值的结点，所有从根结点到各个叶子结点的路径长度与相应叶子结点权值的乘积之和

  哈夫曼树的定义：给定一组具有确定权值的叶子结点，可以构造出不同的二叉树，将其中带权值路径长度最小的二叉树称为哈弗曼树

  对于这个算法来说，一组带权值的叶子结点是不变的，而二叉树的形状是变的 【实际应用场景呢？】
  
  要想构造出一个哈夫曼树，一定是权值大的叶子结点靠近根结点，而权值较小的叶子结点原理根结点：
    构造思想：
      [1]初始化：     由给定的n个权值构造n棵只有一个根结点的二叉树从而得到一个二叉树集合 F
      [2]选取与合并：  在F中选取根结点权值最小的两棵二叉树分别作为左右子树构造一棵新的二叉树，这棵二叉树根结点的权值等于左右权值之和
      [3]删除与加入：  在F中删除作为左右子树的两棵二叉树，并将新建立的二叉树加入F中 
      [4]重复2|3步骤  知道 F 中 只含有1棵二叉树为止
  因为这个构造过程，非叶子结点的度为2，由二叉树性质可知 n0=n2+1，所以一共会有 2n-1 个结点，n-1 次合并的过程

  存储结构，对于树的存储，如果你用了顺序存储结构就是真的蠢，必然是链接存储结构且是三叉链表

  可能由于哈弗曼树的问题一定是先给出确定的N的数量级，所以书本才说用一个数组 huffTree[2n-1] 来进行存储

  | weight | lchild | rchild | parent |
  struct element{
    int weight;
    int lchild,rchild,parent;
  }
  初始令parent为-1，当加入到了哈夫曼树种就令其为双亲结点，因此可以通过parent的值来判断是否加入到了哈夫曼树中【 加入的时候进行判断 】
  
  if weight is not sort，so we must sort it by myself.

#### 课后习题
1、证明：已知一颗二叉树的前序遍历和中序遍历，就可唯一确定一棵二叉树
 编程：1、 已知前序序列和中序序列，输出二叉树序列（每个序列都是一个结点）
      2、 对给定一组键值W，试构造相应的哈弗曼树，求带权值路径 、 编码后的最短编码位
      3、 W=(2,1,4,5,7,3,4,9) 对哈夫曼树进行 [0,1] 编码,该字符编码至少有多少位
      4、 设计算法求二叉树的结点个数
      5、 设计算法按前序次序打印二叉树中的叶子结点
      6、 设计算法求二叉树的深度
      7、 编写算法，要求输出二叉树后续遍历序列的逆序
      8、 以二叉链表为存储结构，编写算法求二叉树中结点X的双亲
      9、 以二叉链表为存储结构，在二叉树中删除以值为X为根结点的子树
      10、一棵具有n个结点的二叉树采用顺序存储结构，编写算法对该二叉树进行前序遍历
      11、编写算法交换二叉树中的所有结点的子树
      12、以孩子兄弟表示法做存储结构，求树中结点X的第I个孩子
  



#### 题外

> 集合		数据之间除了存在与同一个集合之内外，无任何关系
  线性结构	数据元素之间是一对一的线性关系
  树结构		数据元素之间是一对多的层次关系
  图结构		数据元素之间是多对多的任意关系

> KMP 算法
  红黑树，对 平衡二叉树 插入删除操作的优化。其实就是 0 1树嘛，非常常见
  其次就是一些排序算法
  查找算法
  有些数据是先排序再查找呢?还是直接查找，同样是个问题
  广度优先遍历 、 深度优先遍历

  主从同步、架构升级



 