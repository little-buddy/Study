# 图 Graph

## 定义和基本术语
* `顶点` vertex [ 在图中常常将数据元素称为顶点 ]
* `图`
 <br>由顶点的有穷非空集合和顶点之间边的集合组成
 <br> <center>G = (V,E)</center>
 G表示一个图，V是图G中顶点的集合，E是图G中顶点之间边的集合
 <br> 若顶点 vi 和 vj 之间的边没有方向，则称这条边为 `无向边` 用无序偶对(vi,vj)来表示
 <br> 若从顶点vi到vj的边有方向，则称这条边为`有向边(狐)`,有序偶对(vi,vj)表示,vi 称为`弧头`，vj称为`弧尾`
 <br> 如果图的任意两个顶点之间的边都是无向边，则称该图为`无向图`,否则称为`有向图`
 * 图的基本术语
 * * `简单图`
 <br>若不存顶点到其自身的边，且同一条边不重复出现，则称这个图为简单图`simple graph`。__本书只讨论简单图__
* * `邻接、依附`
在无向图中，对于任意两个顶点vi和vj，若存在边(vi,vj),则称vi和vj互为邻接点(adjacent)，同时称边(vi,vj)依附于顶点vi和vj
<br> 在有向图中，通常称vj是vi的邻接点，起点相对于终点
* * `无向完全图、有向完全图`
<br> 在无向图中，如果任意两个顶点之间都存在边，则该图为无向完全图，`undirected complete graph` 含有n个顶点的无向完全图有 `n*(n-1)/2`条边 `Cn(2)`
<br> 在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图`directed complete graph` 含有n个顶点的有向完全图有 `n*(n-1)`条边
* * `稠密图、稀疏图`
<br> 称边数很少的图为稀疏图，反之则为稠密图。相对而言的。
* * `顶点的度、入度、出度`
<br> 有向图中,顶点v的度使之依附于该顶点的边的个数，记`TD(v)`.在具有n个顶点e条边的无向图中，有下列式子
<center>∑<sub>i=0</sub><sup>n-1</sup>TD(vi) = 2*e</center>

* * 在有向图中,顶点v的入度 `in-degree` 是指以该顶点为弧头的弧的个数，记为`ID(v)` 顶点v的出度是指以该顶点为弧尾的弧的个数，记为`OD(v)` 在具有n个顶点e条边的有向图中，有下式成立
<center>∑<sub>i=0</sub><sup>n-1</sup>ID(vi) = ∑<sub>i=0</sub><sup>n-1</sup>OD(vi) = 2*e </center>

* * `权、网`
<br>权`weight`通常是指对边赋予的有意义的数量值，边上带权的图称为网或网图`network graph`
* * `路径、路径长度、回路`
<br> 从顶点vp到vq之间的路径是一个`顶点序列`，路径上边的数目称为路径长度。第一个顶点和最后一个顶点相同的路径称为回路`circuit`或环`ring`
* * `简单路径、简单回路`
<br>在路径序列中，顶点不出现重复的路径称为简单路径`simple path`,除了第一顶点和最后一个顶点之外，其余顶点不重复出现的回路称为简单回路`simple circuit`
* * 子图
<br> 对于 G= (V,E) 和 G’ = (V',E') 
<br> 如果 V‘ ⊆ V 且 E’⊆ E，则G‘是G的子图`subGraph`
* * 连通图、连通分量
<br> 在无向图中，任意顶点vi和vj(i!=j)间是有路径，则称该图为连通图
<br> 非联通图的极大联通子图称为该图的联通分量 `connected comonent`
* * 强连通图、强连通分量
<br> 在有向图中，对任意顶点vi和vj均有路径，则称为强连通图 `strongly connected graph` 非强连通图的极大强联通子图称为强联通分量
* * 生成树、生成森林
<br> 具有n个顶点的连通图G的生成树`spanning tree` 是包含G中全部顶点的一个极小联通子图。连通图生成的是一棵自由树，可以在生成树种任意制定一个顶点为树的根结点。在生成树中添加任意一条属于原图中的边必定会造成回路，删除任意一条边会造成非联通图，所以n个顶点的生成树只有`n-1`条边
<br> 在非连通图中，由每个联通分量都可以构成一个树，这些树构成了 生成森林`spanning forest`

## 图的遍历操作
* 含义：
<br> 基本操作... 指从图中某一顶点出发，对图中所有顶点访问一次且仅访问一次。
<br>[特征]
* * 任意一点都可以作为图的起始顶点
* * 从某一个顶点出发可能到达不了某个顶点，例如 非连通图
* * 由于图中可能存在回路，如何避免重复访问陷入死循环呢
* * 一个顶点可以和其他多个顶点邻接，当这样的顶点访问过后如何选取下一个顶点呢

<br>[按特征解答]
* * 既然没有确定起始顶点，就将顶点编号，先从编号小的顶点开始.
由于2个顶点之间都可能存在边，顶点没有确定的先后顺序。顶点编号不唯一。`在图的存储实现上，一般采用数组存储图的顶点信息，一般采用数组存储图的顶点信息`
* * 要遍历图中的所有顶点，只需多次重复从某一顶点出发进行图的遍历
* * 为了在遍历的过程中便于区分顶点是否已被访问过，设置一个访问标志数组visited[n]，其初始值未被访问表示"0",如果已被访问置为"1"
* * 遍历次序 -> 深度遍历 || 广度遍历

* 深度优先遍历
<br> 1、访问顶点v
<br> 2、从v的未被访问的邻接点选取一个顶点w，。从w出发进行深度遍历
<br> 3、重复上述2步骤，直到图中所有和v右路径想通的顶点都被访问到

* 广度优先遍历 【类似于树的层序遍历】
<br> 1、访问顶点v
<br> 2、依次访问v的各个未被访问的邻接点 v1、v2、v3..，vk
<br> 3、分别从v1，v2..vk 出发一次访问他们的邻接点
<b4> 重复步骤2、3，直到所有顶点都被访问

## 图的存储结构
 顶点信息 + 描述顶点之间关系的信息
* 邻接矩阵【又称数组表示法】[ adjacency matrix ]
<br> 用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息。而这个二维数组称为邻接矩阵
```  
【 邻接矩阵示意图 】

图       
            |- 1  若 (vi,vj) ∈ E 或 < vi  vj >
arc[i][j] = |
            |- 0 否则

网图
            |- wij 若 (vi,vj) ∈ E 或 < vi  vj >
arc[i][j] = |  0   i=j
            |- ∞   否则

  无向图的邻接矩阵一定是对称矩阵，而有向图的邻接矩阵不一定对称
```
* * 邻接矩阵解决的问题
* * * 对于无向图，顶点I的度等于邻接矩阵的第i行非零元素的个数。对于有向图，顶点i的出度等于邻接矩阵的第i行非零元素的个数；顶点i的入度等于邻接矩阵的第i列非零元素的个数
* * * 要判断顶点 i 和 j 之间是否存在边，只需要测试邻接矩阵中相应位置的元素 arc[i][j]若为1有边，若为0无边
* * * 找到顶点i的所有邻接点，可依次判别顶点i与其他顶点之间是否有边【弧】
<br>时间复杂度 -> o(n^2)
* 邻接表  [ adjacency list ]
<br> 顺序存储于链接存储相结合的存储方法，类似于树的 `孩子链表表示法`
<br> 对于图的每个顶点vi，将所有邻接于vi的顶点链接成一个单链表 `边表`
<center>顶点表结构:|vertex|firstedge| 边表结构:|adjvex|(weight[网]|)next| </center> 

* * 邻接表解决的问题
* * * 对于无向图，顶点I的度等于顶点i表中的结点个数。在有向图中，顶点i的出度等于边表中顶点I的结点个数，顶点i的入度等于各顶点出边表中以顶点i为终点的结点个数
* * * 要判断顶点i和顶点j之间是否存在边，只需遍历顶点I的出边表中是否存在域为j的邻接点
* * * 找顶点i所有的邻接点，只需要遍历顶点I的出边表，该出边表中所有结点都是顶点i的邻接点

* 十字链表  [ orthogonal list ]
<br> 有向图的一种存储方式。邻接表与逆邻接表的结合。
<br> 顶点表结构: |vertex|firstin|firstout|
<br> 边表结构: |tailvex|headvex|headlink|taillink|
<br> tail作为起点,head作为重点，link表示边

* 邻接多重表 [ adjacency multi-list ]
<br> 主要用于存储无向边
<br> 每条边的两个顶点分别在以该边所依附的两个顶点的边表中，存在重复存储。为优化而产生了 `邻接多重表`
<br> 顶点表结构: |vertex|firstedge|  边表结构: |ivex|ilink|jvex|jlink
```
点的思考角度 -> 边的思考角度 -> 优化了边的存储方式
```
* 邻接矩阵 和 邻接表的比较
* * 空间性能比较
<br> O(n^2) O(n+e)
<br> 哪种表示方法的存储效率高取决于图中边的数目，邻接表仅存储实际出现在图中的边，而邻接矩阵则需要存储所有可能的边，但是邻接矩阵没有指针的结构性开销。一般情况下，图越稠密，邻接矩阵的空间效率相应地越高，而对稀疏图则使用邻接表
* * 时间性能比较
<br> 与邻接表相比，邻接矩阵在图的算法中时间代价较高，其原因是：在图的算法中访问某个顶点的所有邻接点是较常见的。如果使用邻接表，则只需要检查此顶点的边表，即只检查与它相邻的实际存在的边，平均需要O(e/n)次，如果使用邻接矩阵，则必须检查所有可能的边，需要查找O(n)次
* * 唯一性比较
<br> 当图中每个顶点的编号确定后，图的邻接矩阵表示是唯一的，所以从某一个顶点触发进行深度或广度遍历的时候，顶点次序也是唯一的；但图的邻接表表示不是唯一的，它与边的输入次序和结点在边表的插入算法有关，所以对于同一个图的不同邻接表进行深度或广度遍历的顶点次序不唯一
* * 对应关系
<br> 邻接表中每个顶点的边表对应邻接矩阵的第i行，整个邻接表可以看作是邻接矩阵带行指针的链接存储

## 最小生成树 [ minimal spanning tree ]
<br> 设 G = (V,E) 是一个无向连通图，生成树上各边的权值之和称为该生成树的代价，在G的所有生成树中，代价最小的生成树称为最小生成树(huffTree 最短的带权值路径长度)
MST性质：假设 G = (V,E) 是一个无向连通网，U是顶点V的一个非空子集。若(u,v)是一条最小权值边,其中` u ∈ U, v ∈ V-U`,则必然存在一棵包含边(u,v)的最小生成树
### Prim算法
<br> 基本思路
<br> 设 G = (V,E)是一个无向连通网，另 T=(U,TE) 是G的最小生成树。T的初始状态U={v。}(v。∈ V),TE = {},重复执行下述操作：在所有u ∈ U，v ∈ V-U的边中找一条代价最小的边(u,v)并入集合TE，同时 v 并入U，直至U=V。此时TE中必有n-1条边，则T就是一棵最小生成树

### Kruskal算法
<br> 基本思路
<br> 设无向联通网 G = (V,E),令G的最小生成树为 T=(U,TE),其初态为U=V,TE={},这样T中各顶点各自构成一个联通分量。然后按照边的权值由小到大的顺序，依次考察边集E中的各条边。若被考擦的两个顶点属于T的两个不同的连通分量，则将此边加入到TE中，同时把两个两桶分量连接到一个连通分量；若被考擦的边属于一个连通分量，则舍去此边，以免造成回路，如此下去，当T中的连通分量个数为1时，此连通分量便为G的一棵最小生成树
<br> [思考] 这里有点像huffTree，每个联通分量之间两两结合边并入TE
<br> 对于树与图，都是基于现有数据完整的情况下去寻找需要的结果，必然存在存储方式的选择，以及遍历方式的选择

## 最短路径
<br> 在非网图中，最短路径`shortest path` 是指两顶点之间经历的边数最少的路径，路径上第一个顶点称为源点`source`,最后一个顶点称为终点`destination`
<br> 在网图中，最短路径是指两顶点之间经历的边上权值之和最少的路径
<br> 注：本节讨论有向网图的最短路径问题

### Dijkstra算法
<br> 用于求解单源点最短路径问题。给定带权有向图 G=(V,E)和源点 v ∈ V，求v到G中其余各顶点的最短路径
<br> 基本思想：
<br> 设置一个集合S存放已经找到最短路径的顶点,S的初始状态只包含源点v,对vi ∈ V-S，假设从源点v到vi的有向边为最短路径。以后每求得一条最短路径v...vk，就将vk加入集合S，并将v,...,vk,vi与原来的假设相比较，取路径长度较小者为当前最短路径。重复上述过程直到V中全部顶点加入到集合S中

### Floyd算法
<br> 用于求每一对顶点之间的最短路径问题。给定带权有向图 G=(V,E),对任意点vi和vj(i!=j),求顶点vi到顶点vj的最短路径
<br> 【题外】 解决这类问题的一个办法：每次以一个顶点为源点，调用Dijkstra算法n次，便可求得每一对顶点之间的最短路径，而两个算法的时间复杂度O(n^3)，但形式上Floyd要简单
<br> 基本思路：
<br> 假设从vi到vj的弧是最短路径，然后进行n次试探。首先比较vi，vj和vi，v0，vj的路径长度，取长度较短者作为从vi到vj中间顶点的编号不大于0的最短路径。在路径上再增加一个顶点v1，将vi...v1...vj和已经得到的从vi到vj中间顶点的编号不大于0的最短路径相比较，取长度较短者作为中间顶点的编号不大于1的最短路径。以此类推，在一般情况下，若vi...vk和vk...vj分别是从vi到vk和从vk到vj中间顶点的编号不大于k-1de最短路径，则将vi...vk...vj和已经得到的从vi到vj中间顶点的编号不大于k的最短路径比较，去长度较短者为vi到vj中间顶点的编号不大于k的最短路径。经过n次比较之后，最后求得的必是从vi到vj的最短路径

## 有向无环图及其应用
<br> 本节讨论有向图 `拓扑排序` 和 `关键路径`
### AOV网与拓扑排序
<br> 在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的关系，称这样的有向图为顶点表示活动的网，简称AOV网`activity on vertex network`
<br> AOV网中的弧表示了活动之间存在某种制约关系。在AOV网中不能出现回路，否则意味着某活动的开始要以自己的完成作为先决条件。意味着判断AOV网所代表的工程能否顺利进行，即判断它是否存在回路。而测试AOV网是否存在回路的方法就是对AOV网进行拓扑排序
<br> 设 G = (V,E) 是一个有向图，V中的顶点序列v0,v1,...,vn-1 称为一个拓扑序列`topological order`,当且仅当满足下列条件:若从顶点vi到vj有一条路径，则称顶点vi必在vj之前。对一个有向图构造拓扑序列的过程称为`拓扑排序`[偏序关系]
<br> 拓扑序列不唯一
<br> 对AOV网进行拓扑排序的基本思路：
<br> 1、对AOV网中选择一个没有前驱的顶点并且输出它
<br> 2、从AOV网中删除该顶点，并且删除所有以该顶点为尾的弧
<br> 3、重复上述步骤，直到全部顶点都被输出，或AOV网中不存在没有前驱的结点
### AOE网与关键路径
<br> 在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，边上的权值表示活动的持续时间，成这样的有向图为边表示的网，简称AOE网`activity on edge network`。没有入边的顶点称为`源点`，没有出边的顶点称为`终点` vertex -> 事件 edge -> 活动
<br> 具有最大路径长度的路径称为`关键路径 cirtical path`，关键路径上的活动称为`关键活动 cirtical activity`
* 事件最早发生时间 ve
```
ve[0]=0
ve[k]=max{ve[i]+len<vi,vk>}, <vi,vk> ∈ p[k],p[k]表示所有到达vk的有向边集合
```
* 事件最晚发生时间 vl
```
vl[n-1]=ve[n-1]
vl[k] = min{vl[j]-len<vk,vj>} <vk,vj> ∈ s[k],s[k]表示所有从vk出发的有向边集合
```
* 活动最早发生时间 ee
```
活动 <vk,vj>,某一条边的最早发生事件等于该边的源点的最早发生时间

ee[i] = ve[k]
```
* 活动最晚发生时间 el
```
活动 <vk,vj>,某一条边的最晚发生时间是该边的终点的最晚发生时间减去
el[i] = vl[j]-len<vk,vj>
```
对于关键路径的求解，书上给出的例子是：
<br> 1、获得一个具有vl，ve的有向图，并且序列符合拓扑排序
<br> 2、对该有向图进行 ee,el的计算
<br> 3、若ee==el，这该活动为关键活动，最终所有的集合组成关键路径 