# 图 Graph

## 定义和基本术语
* `顶点` vertex [ 在图中常常将数据元素称为顶点 ]
* `图`
 <br>由顶点的有穷非空集合和顶点之间边的集合组成
 <br> <center>G = (V,E)</center>
 G表示一个图，V是图G中顶点的集合，E是图G中顶点之间边的集合
 <br> 若顶点 vi 和 vj 之间的边没有方向，则称这条边为 `无向边` 用无序偶对(vi,vj)来表示
 <br> 若从顶点vi到vj的边有方向，则称这条边为`有向边(狐)`,有序偶对(vi,vj)表示,vi 称为`弧头`，vj称为`弧尾`
 <br> 如果图的任意两个顶点之间的边都是无向边，则称该图为`无向图`,否则称为`有向图`
 * 图的基本术语
 * * `简单图`
 <br>若不存顶点到其自身的边，且同一条边不重复出现，则称这个图为简单图`simple graph`。__本书只讨论简单图__
* * `邻接、依附`
在无向图中，对于任意两个顶点vi和vj，若存在边(vi,vj),则称vi和vj互为邻接点(adjacent)，同时称边(vi,vj)依附于顶点vi和vj
<br> 在有向图中，通常称vj是vi的邻接点，起点相对于终点
* * `无向完全图、有向完全图`
<br> 在无向图中，如果任意两个顶点之间都存在边，则该图为无向完全图，`undirected complete graph` 含有n个顶点的无向完全图有 `n*(n-1)/2`条边 `Cn(2)`
<br> 在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图`directed complete graph` 含有n个顶点的有向完全图有 `n*(n-1)`条边
* * `稠密图、稀疏图`
<br> 称边数很少的图为稀疏图，反之则为稠密图。相对而言的。
* * `顶点的度、入度、出度`
<br> 有向图中,顶点v的度使之依附于该顶点的边的个数，记`TD(v)`.在具有n个顶点e条边的无向图中，有下列式子
<center>∑<sub>i=0</sub><sup>n-1</sup>TD(vi) = 2*e</center>

* * 在有向图中,顶点v的入度 `in-degree` 是指以该顶点为弧头的弧的个数，记为`ID(v)` 顶点v的出度是指以该顶点为弧尾的弧的个数，记为`OD(v)` 在具有n个顶点e条边的有向图中，有下式成立
<center>∑<sub>i=0</sub><sup>n-1</sup>ID(vi) = ∑<sub>i=0</sub><sup>n-1</sup>OD(vi) = 2*e </center>

* * `权、网`
<br>权`weight`通常是指对边赋予的有意义的数量值，边上带权的图称为网或网图`network graph`
* * `路径、路径长度、回路`
<br> 从顶点vp到vq之间的路径是一个`顶点序列`，路径上边的数目称为路径长度。第一个顶点和最后一个顶点相同的路径称为回路`circuit`或环`ring`
* * `简单路径、简单回路`
<br>在路径序列中，顶点不出现重复的路径称为简单路径`simple path`,除了第一顶点和最后一个顶点之外，其余顶点不重复出现的回路称为简单回路`simple circuit`
* * 子图
<br> 对于 G= (V,E) 和 G’ = (V',E') 
<br> 如果 V‘ ⊆ V 且 E’⊆ E，则G‘是G的子图`subGraph`
* * 连通图、连通分量
<br> 在无向图中，任意顶点vi和vj(i!=j)间是有路径，则称该图为连通图
<br> 非联通图的极大联通子图称为该图的联通分量 `connected comonent`
* * 强连通图、强连通分量
<br> 在有向图中，对任意顶点vi和vj均有路径，则称为强连通图 `strongly connected graph` 非强连通图的极大强联通子图称为强联通分量
* * 生成树、生成森林
<br> 具有n个顶点的连通图G的生成树`spanning tree` 是包含G中全部顶点的一个极小联通子图。连通图生成的是一棵自由树，可以在生成树种任意制定一个顶点为树的根结点。在生成树中添加任意一条属于原图中的边必定会造成回路，删除任意一条边会造成非联通图，所以n个顶点的生成树只有`n-1`条边
<br> 在非连通图中，由每个联通分量都可以构成一个树，这些树构成了 生成森林`spanning forest`

## 图的遍历操作
* 含义：
<br> 基本操作... 指从图中某一顶点出发，对图中所有顶点访问一次且仅访问一次。
<br>[特征]
* * 任意一点都可以作为图的起始顶点
* * 从某一个顶点出发可能到达不了某个顶点，例如 非连通图
* * 由于图中可能存在回路，如何避免重复访问陷入死循环呢
* * 一个顶点可以和其他多个顶点邻接，当这样的顶点访问过后如何选取下一个顶点呢

<br>[按特征解答]
* * 既然没有确定起始顶点，就将顶点编号，先从编号小的顶点开始.
由于2个顶点之间都可能存在边，顶点没有确定的先后顺序。顶点编号不唯一。`在图的存储实现上，一般采用数组存储图的顶点信息，一般采用数组存储图的顶点信息`
* * 要遍历图中的所有顶点，只需多次重复从某一顶点出发进行图的遍历
* * 为了在遍历的过程中便于区分顶点是否已被访问过，设置一个访问标志数组visited[n]，其初始值未被访问表示"0",如果已被访问置为"1"
* * 遍历次序 -> 深度遍历 || 广度遍历

* 深度优先遍历
<br> 1、访问顶点v
<br> 2、从v的未被访问的邻接点选取一个顶点w，。从w出发进行深度遍历
<br> 3、重复上述2步骤，直到图中所有和v右路径想通的顶点都被访问到

* 广度优先遍历 【类似于树的层序遍历】
<br> 1、访问顶点v
<br> 2、依次访问v的各个未被访问的邻接点 v1、v2、v3..，vk
<br> 3、分别从v1，v2..vk 出发一次访问他们的邻接点
<b4> 重复步骤2、3，直到所有顶点都被访问

## 图的存储结构
 顶点信息 + 描述顶点之间关系的信息
* 邻接矩阵【又称数组表示法】[ adjacency matrix ]
<br> 用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息。而这个二维数组称为邻接矩阵
```  
【 邻接矩阵示意图 】

图       
            |- 1  若 (vi,vj) ∈ E 或 < vi  vj >
arc[i][j] = |
            |- 0 否则

网图
            |- wij 若 (vi,vj) ∈ E 或 < vi  vj >
arc[i][j] = |  0   i=j
            |- ∞   否则

  无向图的邻接矩阵一定是对称矩阵，而有向图的邻接矩阵不一定对称
```
* * 邻接矩阵解决的问题
* * * 对于无向图，顶点I的度等于邻接矩阵的第i行非零元素的个数。对于有向图，顶点i的出度等于邻接矩阵的第i行非零元素的个数；顶点i的入度等于邻接矩阵的第i列非零元素的个数
* * * 要判断顶点 i 和 j 之间是否存在边，只需要测试邻接矩阵中相应位置的元素 arc[i][j]若为1有边，若为0无边
* * * 找到顶点i的所有邻接点，可依次判别顶点i与其他顶点之间是否有边【弧】
<br>时间复杂度 -> o(n^2)
* 邻接表  [ adjacency list ]
<br> 顺序存储于链接存储相结合的存储方法，类似于树的 `孩子链表表示法`
<br> 对于图的每个顶点vi，将所有邻接于vi的顶点链接成一个单链表 `边表`
<center>顶点表结构:|vertex|firstedge| 边表结构:|adjvex|(weight[网]|)next| </center> 

* * 邻接表解决的问题
* * * 对于无向图，顶点I的度等于顶点i表中的结点个数。在有向图中，顶点i的出度等于边表中顶点I的结点个数，顶点i的入度等于各顶点出边表中以顶点i为终点的结点个数
* * * 要判断顶点i和顶点j之间是否存在边，只需遍历顶点I的出边表中是否存在域为j的邻接点
* * * 找顶点i所有的邻接点，只需要遍历顶点I的出边表，该出边表中所有结点都是顶点i的邻接点

* 十字链表  [ orthogonal list ]
<br> 有向图的一种存储方式。邻接表与逆邻接表的结合。
<br> 顶点表结构: |vertex|firstin|firstout|
<br> 边表结构: |tailvex|headvex|headlink|taillink|
<br> tail作为起点,head作为重点，link表示边

* 邻接多重表 [ adjacency multi-list ]
<br> 主要用于存储无向边
<br> 每条边的两个顶点分别在以该边所依附的两个顶点的边表中，存在重复存储。为优化而产生了 `邻接多重表`
<br> 顶点表结构: |vertex|firstedge|  边表结构: |ivex|ilink|jvex|jlink
```
点的思考角度 -> 边的思考角度 -> 优化了边的存储方式
```
* 邻接矩阵 和 邻接表的比较
* * 空间性能比较
<br> O(n^2) O(n+e)
<br> 哪种表示方法的存储效率高取决于图中边的数目，邻接表仅存储实际出现在图中的边，而邻接矩阵则需要存储所有可能的边，但是邻接矩阵没有指针的结构性开销。一般情况下，图越稠密，邻接矩阵的空间效率相应地越高，而对稀疏图则使用邻接表
* * 时间性能比较
<br> 与邻接表相比，邻接矩阵在图的算法中时间代价较高，其原因是：在图的算法中访问某个顶点的所有邻接点是较常见的。如果使用邻接表，则只需要检查此顶点的边表，即只检查与它相邻的实际存在的边，平均需要O(e/n)次，如果使用邻接矩阵，则必须检查所有可能的边，需要查找O(n)次
* * 唯一性比较
<br> 当图中每个顶点的编号确定后，图的邻接矩阵表示是唯一的，所以从某一个顶点触发进行深度或广度遍历的时候，顶点次序也是唯一的；但图的邻接表表示不是唯一的，它与边的输入次序和结点在边表的插入算法有关，所以对于同一个图的不同邻接表进行深度或广度遍历的顶点次序不唯一
* * 对应关系
<br> 邻接表中每个顶点的边表对应邻接矩阵的第i行，整个邻接表可以看作是邻接矩阵带行指针的链接存储

## 最小生成树