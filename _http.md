# HTTP

## what is http?
> http HyperText Transfer protocol
> 处于计算机网络的应用层，它是建立在 TCP 协议之上，所以http的瓶颈及其优化都是建立在TCP协力本身的特性

## Tcp 是什么？
> 数据传输又分 UDP TCP 最终 + IP 组成一个以太网数据包
每个数据包的最大有效发送数据量在 1400个字节，那数据量较大的文件
在发送的过程中就存在被分成多个包的情况，而TCP 会对每个包进行编号
以便接收的一方按顺序还原，并且每个包会记录自己的编号以及下一个包的编号

对于通过TCP传输的包最终是由操作系统完成的，组装完成之后传递给应用程序 

假如说人的反应时间是300ms，那只要小于这个请求时间都是合理的
并不需要过多的优化，通过websocket一次性请求和底层使用TCP其实
是无差的

TCP协议为了做到效率与可靠性的统一，设计了一个慢启动（Slow Start）机制
开始的时候发送较慢，然后根据丢包的情况自动调整发送速率

ACK{
	期待要收到下一个数据包的编号
	接收方的接收窗口的剩余容量
}
ACK 确保了TCP协议的数据完整性

如果接受超过3个重复ACK，TCP就会确认丢包从而要求客户端重新发包

### 三次握手 [ 序列号就是发送的编号，如果发送不携带数据则不消耗序列号 ]
> 最开始的时候客户端和服务端都是处于CLOSED 状态。主动打开连接的为客户端，被动打开连接的是服务器
1、服务端进程创建传输控制块 TCB（Transfer Control Block），此时服务器就进入了 LISTEN 状态
2、【SYN-SENT】
TCP 客户端也是先创建传输控制块TCB，然后向服务器发送连接请求报文，有一个标记 SYN = 1， seq=x。不能携带数据但要消耗一个序号
3、【SYN-RECE】
TCP服务器接受请求报文，如果同意连接则发出确认报文，ACK =1 SYN =1 ack = x+1,同时为自己初始化一个 seq =y。不带数据消耗序列号
4、TCP 客户端接收到确认后，还要向服务器给出确认。确认的报文 ACK = 1,ack = y +1,序列号 x+1
5、当服务器接受到客户端请求后，就可以开始通信了

总结起来就是客户端与服务器互相初始化并确认数据传输的起始编号，由于他们都有双方编号的依赖只能是同步的，无法异步

本质上二次握手就完成了，第三次握手的客户端请求时为了防止 网络滞后性导致多次传输 同一资源
	一般客户端如果在一定时间内没有收到服务器的确认报文会重新发送，但实际上是因为网络的滞后性导致服务器在规定时间之外获取

在请求结尾处进行了 中断处理

### 四次挥手 [报文发送之后进入的状态]
> 数据传输完毕，双方都可释放连接。最终服务端被动关闭，客户端主动关闭
1、【FIN-WAIT-1】
客户端进程发出连接释放报文， FIN =1，seq= u(seq[final]+1),客户端进入终止等待的状态，FIN即使不携带数据也要消耗一个序号
2、【CLOSE-WAIT】
服务器收到连接释放报文，发出确认报文ACK=1，ack = u+1，并附上 seq =v
半关闭状态。即客户端没有数据要发送了，但服务端若有数据，客户端仍要接受
3、【FIN-WAIT-2】
接受到服务端请求，进入终止等待状态-2，等待服务器发送连接释放报文（还要接受服务器数据）
4、【LAST-ACK】
服务器将最后的数据发送完毕后就向客户段发送 FIN=1 ack=u+1,seq = w,等待客户端确认
5、客户端接收服务端的连接释放报文，必须发出确认 ACK = 1 ack=w+1 ,seq= u+1，客户端就进入了TIME-WAIT
此时TCP并没有释放，必须经过 2 * MSL(最长报文段寿命) 的时间后，客户端撤销响应的TCB，才进入CLOSED状态
6、服务器只要接收到了客户端发出的确认，立即进入CLOSED状态撤销 TCB
服务端结束TCP的连接时间要比客户端早一些

客户端告诉服务端我数据传完了，服务端确认，双方进入一个收尾状态 
服务端告诉客户端我收尾完成了，客户端再告诉服务端那我们就结束吧
终止了连接

2MSL 的等待时长是为了让客户端确保服务端收到了终止报文

如果建立了连接，客户端出现了故障，服务器一般当超时处理，发送探测报文，如果仍旧没反应，关闭连接

即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中如果出现了丢包，UDO也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交给由采用UDO的应用程序去处理。


还是需要花点时间去了解一下java里面的线程安全性问题
If-Modifined-Since \ Expires \ Entity tag \ if-Unmodifined \ If-Match \ If-None-Match \


HTTP的基本优化
* 带宽 21世纪 10年代 以后基本不用考虑
* 延迟
	* 浏览器阻塞 一个浏览器对同一时刻的连接数有所限制
	* DNS 查询  浏览器需要知道目标的IP才能建立连接，将域名解析为IP的系统称为DNS，一般使用DNS缓存
	* 建立连接  HTTP 是基于 TCP的，三次握手才能传输数据，以及传输时的慢启动，而建立连接无法复用导致
		这个延迟时长是很明显的，慢启动对于文件类影响较大

### HTTP 1.0 和 HTTP 1.1
> 1.0 是 96年开始投入使用 / 1.1 是 99年开始投入使用 
* 缓存处理
  * if-Modified-Since,Expires =>  Entity tag / If-Unmodified-Since / If-Match / If-None-Match
* 带宽优化及网络连接的使用
  * 优化了带宽浪费现象，例如客户端只需要一部分，服务端却将整个都给了我，并且不支持断点续传功能
* 错误通知的管理
  * 新增了一些返回码的异常
* Host头处理
  * 每台服务器都绑定一个唯一的IP地址，请求消息的头中没有传递hostname，随着虚拟技术发展，一台IP上回存在多个主机
  所以新增了hostname绑定
* 长连接
  * 1.1 支持长链接 和 请求的流水线。在一个TCP连接上可以传递多个HTTP请求 和 响应
  为了减少建立和关闭连接的消耗和延迟，在 1.1 中默认开启了 Connection: keep-alive 
  而对于图片这类非业务类的请求使用keep-alive 会对服务器产生巨大压力，因为它不需要长连接

#### 缺点：1.X 
* 每次都需要建立新连接
* 数据的传输都是明文，一定程度上无法保护数据的安全性
* header里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求header基本不怎么变化
* keep-alive 会造成性能影响


其实它的设计路线是从 HTTP 1.0 -> HTTP 1.1 -> HTTPS -> SPDY( 2012 谷歌做了一波推动) -> HTTP 2.0

HTTP 1.1 相较于 HTTP1.O 增加了更多的缓存选项，减少了不必要的传输量、增加了更多的错误返回码、header强制添加hostname
可以多个请求公用一个TCP【长连接】

HTTPS 就是 HTTP + SSL 认证，运行在 443 端口
 http -> https 改造：
  1、安装CA证书，配置到web服务器
  2、由于 ssl 握手、密钥的加密算法 会降低 https的访问速度，需要做一些优化处理

### SPDY[speedY]
* 【降低延迟】 采用了多路复用，通过多个stream共享一个TCP
* 【请求优先级】 多路复用会带来一个问题就是可能会造成关键请求阻塞，所以可以为每个request设置一个优先级
* 【header压缩】 通过压缩减少包的大小和数量
* 【基于HTTPS的机密协议传输】 
* 【服务端推送】
估计iframe流 用的就是这种技术进行服务端推送

### http 2.0  spdy 的升级版
 不同：http2.0 支持明文传输，而spdy强制使用https，前者压缩算法【HPACK】，后者压缩算法【DEFLATE】

 新的二进制格式，HTTP1.x采用的是文本协议，而2.x使用二进制
 多路复用
 header压缩
 服务端推送

 对于HTTP2.O的升级改造
  其实http2.0本身就兼容http1.x，但是现在主流浏览器 chrome firefox表示还是只支持TLS部署的http2。0，所以升级时最好先升级https
  nginx的配置就能自动升级成http2.0， 这里可以看出http2.0 是一种协议解析，中间层就可以处理





































