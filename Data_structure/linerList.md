# 线性表
    元素之间存在一对一的线性关系

## 线性表的逻辑结构
>* n(n>=0) 个具有相同数据类型的数据元素的有限序列。线性表中数据元素的个数称为线性表的长度，长度等于0时称为空表
>* 除了队首与队尾，都只有一个前驱和一个后继
>* 线性表有的方法
> > - InitList 初始化
> > - DestroyList 摧毁
> > - length 长度
> > - get 获得
> > - locate 返回查找元素的下标
> > - insert 插入
> > - delete 删除
> > - empty 空
> > - printList 按序号依次输出元素

## 线性表的顺序存储结构及实现 【顺序表】
    线性表的顺序存储结构称为顺序表
    由一段地址连续的存储单元依次存储线性表的数据元素，由于线性表中的每个数据元素的类型相同，通常用一维数组来实现线性表
    又由于数组的下标是从0开始的，而现行表的下标是从1开始的，所以线性表第i个元素存储在数组下标为i-1的位置
    顺序表就意味着要分配固定长度的数组空间，必须确定数组的长度，即存放线性表的数组空间的长度

> 特点：
>> 顺序表中数据元素的存储地址是其序号的线性函数，只要确定了顺序表的其实地址，计算任意一个元素的存储地址时间相等。具有这一特点的存储结构称为 随机存取<br>
    按位查找 O(1)   按值查找 O(N)   插入、删除 O(N) 这些都是最基础的操作<br>
    ~~对于一个算法的参数校验来说，一般就是判断 是否越界~~

>缺点：<br>
> * 插入、删除操作需要移动大量的元素，等概率的情况下需要移动表中一半的元素
> * 表的容量难以确定，由于数组的长度必须事先确定，因此线性表的长度变化较大时难以确定合适的存储规模（这确实是初期在写C时的一个灾难）
> * 造成存储空间的"碎片"，因为顺序表要求连续的存储单元，即使存储单元超过所需的存储空间，不连续也不能使用，造成空间的碎片化<br>

>以上是静态存储分配的缺点，而链接存储结构就是采用动态存储分配<br>
`静态存储分配` 在编译的时为变量分配内存，并且一经分配就始终占有固定的存储单元，直到该变量退出其作用域<br>
`动态存储分配` 程序运行期间根据存储需要随时申请内存，并在不需要的时候释放


## 线性表的链接存储及实现 【链表】
### 单链表
> 用一组任意的存储单元用来存放线性表的元素，存储单元可以连续也可以不连续，甚至可以零散地分布在内存中的任意位置
为了能正确地表示数据元素之间的关系，每个存储单元在存储数据的同时还需要存储其后继元素所在的地址信息 这个地址信息 `指针` <br>
这两部分组成了数据元素的存储映像 `结点`  `|data -数据域|next -指针域|` <br>

>单链表每个结点的存储地址都存放在其前驱结点的next域中，而第一个元素无前驱，所以设 `头指针` 整个单链表的存储必须从头指针开始，因而头指针具有标识一个单链表的作用<br>
由于最后一个元素无后继，故最后一个元素所在结点的next域为空，即 NULL `尾标志`<br>
`头结点` 因为第一个元素无前驱需要特殊处理，为了避免算法的复杂性以及bug率，就在第一个元素前增加了data域为空的头结点，头指针一开始指向头结点<br>
单链表遍历算法 求线性表的长度算法 单链表按位查找算法 单链表按值查找算法 单链表插入算法 头插法建立单链表 尾插法建立单链表 单链表删除算法<br>
头插法其实就是在头结点与第一个元素之间插入元素 尾插法就是在最后一个元素之后插入一个结点

### 循环链表
    在单链表中，如果将终端结点的指针域由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为 `循环链表`
> 它的意义在于，对于单链表找到起始结点的时间复杂度为O(1)，而找到尾结点的时间复杂度为O(N)，一般对于链表的操作又多在队首或队尾<br>
所以才有了循环链表，但也因此有了一定的缺陷，就是没有判断循环结束的标志，也因此加了一个是否等于某个特定结点作为判断标志
<br> `顺序存取` 在查找成功的情况，若查找位置为i(1<=i<=n),则需要执行i-1次，等概率的情况下，时间复杂度为O(N)，这种称为顺序存取

### 双链表
    解决了单链表找尾结点的麻烦，又出来一个 寻找前驱结点的时间复杂度为O(N) 所以就又提出了一个双链表的概念

## 顺序表和链表的比较
    决定数据结构使用线性表的时候，就要考虑时间性能和空间性能来选择 顺序表还是链表
> 时间性能比较
<br> 插入和删除操作较多的时候，选择链表要比顺序表好，因为链表的时间复杂度为O(1) 而顺序表的时间复杂度为O(N)，频繁用于查找的则用线性表比较好
<br><br>空间性能比较
<br>`存储密度 = 数据域占用的存储量/整个结点占用的存储量`
<br> 顺序表中每个结点只存放数据元素，存储密度=1，而链表中每个结点存放数据元素之外还存储数据元素之间的指针关系，由此看来顺序表的存储空间利用率较高
<br> 又因为顺序表需要预先分配一定长度的存储空间，过大会造成存储浪费，过小会造成上溢

所以 在元素个数变化较大或未知时，最好用链表实现；如果事先知道线性表的大致长度，使用顺序表的空间效率会更高

## 线性表的其他存储方式
> `静态链表` 用数组来表示单链表，用数组元素下标来模拟单链表的指针。由于它是静态存储分配又模拟了单链表的结构，所以它叫静态链表。
>> 数组下标为0的结点往往作为头指针，first指向有效链，avail指向空闲链

> `间接寻址` 就是原本数组是存数据元素的，现在用来存放指向数据元素的指针，理论分析时间复杂度是没有变的，但从底层来看它对插入、删除操作会比线性表效率高

