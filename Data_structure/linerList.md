# 线性表
    元素之间存在一对一的线性关系

## 线性表的逻辑结构
>* n(n>=0) 个具有相同数据类型的数据元素的有限序列。线性表中数据元素的个数称为线性表的长度，长度等于0时称为空表
>* 除了队首与队尾，都只有一个前驱和一个后继
>* 线性表有的方法
> > - InitList 初始化
> > - DestroyList 摧毁
> > - length 长度
> > - get 获得
> > - locate 返回查找元素的下标
> > - insert 插入
> > - delete 删除
> > - empty 空
> > - printList 按序号依次输出元素

## 线性表的顺序存储结构及实现 【顺序表】
    线性表的顺序存储结构称为顺序表
    由一段地址连续的存储单元依次存储线性表的数据元素，由于线性表中的每个数据元素的类型相同，通常用一维数组来实现线性表
    又由于数组的下标是从0开始的，而现行表的下标是从1开始的，所以线性表第i个元素存储在数组下标为i-1的位置
    顺序表就意味着要分配固定长度的数组空间，必须确定数组的长度，即存放线性表的数组空间的长度

    特点： 顺序表中数据元素的存储地址是其序号的线性函数，只要确定了顺序表的其实地址，计算任意一个元素的存储地址时间相等。具有这一特点的存储结构称为 随机存取

    按位查找 O(1)   按值查找 O(N)   插入、删除 O(N) 这些都是最基础的操作
    ~~对于一个算法的参数校验来说，一般就是判断 是否越界~~

    缺点：
        - 插入、删除操作需要移动大量的元素，等概率的情况下需要移动表中一半的元素
        - 表的容量难以确定，由于数组的长度必须事先确定，因此线性表的长度变化较大时难以确定合适的存储规模（这确实是初期在写C时的一个灾难）
        - 造成存储空间的"碎片"，因为顺序表要求连续的存储单元，即使存储单元超过所需的存储空间，不连续也不能使用，造成空间的碎片化
        以上是静态存储分配的缺点，而链接存储结构就是采用动态存储分配

## 线性表的链接存储及实现 【链表】
### 单链表
> 用一组任意的存储单元用来存放线性表的元素，存储单元可以连续也可以不连续，甚至可以零散地分布在内存中的任意位置<br>
为了能正确地表示数据元素之间的关系，每个存储单元在存储数据的同时还需要存储其后继元素所在的地址信息 这个地址信息***指针***<br>
这两部分组成了数据元素的存储映像***结点***<br>
|data|next|<br>

