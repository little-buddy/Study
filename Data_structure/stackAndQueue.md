# 栈和队列

## 栈 stack
> 限定仅在表尾进行插入和删除操作的线性表，不含任何数据元素的栈称为空栈
<br>允许插入和删除的一端称为 `栈顶`
<br>另一端称为 `栈底`
<br>特性：后进先出 last in first out LIFO，按一定顺序入栈，但出栈的顺序不唯一

### 顺序栈
    栈的顺序存储结构称为顺序栈，顺序栈本质上是顺序表的简化，下标为0的一端作为栈底

> top指针为-1时表示空栈
<br> `两栈共享空间`
<br> 由于顺序栈的单向延伸的特性，使用一个数组来存储两个栈，一个栈的栈底为该数组的始端，另一个栈的栈底为该数组的末端，每个栈的端点向中间延伸
<br> 临界点是 top1 = top2 -1
<br> 比较适合当两个栈的空间需求相反时

### 链栈
    栈的链接存储结构称为链栈
> 结构的话是与单链表的结点结构相同，因为只能在栈顶进行增删，那单链表的头部做栈顶是最方便的,且不需要一个头结点的
<br> 其实就是单链表的头插法去构建一个单链表
<br> 判空操作 top == NULL

### 顺序栈和链栈的比较
    其实还是从顺序表和单链表的优缺点进行比较，由于栈只需要在栈顶进行增删，所以对于线性表的操作时间复杂度都是O(1)的常量
    对于顺序栈来说需要提前确定栈的空间长度，容易造成上溢或者空间浪费，而链栈会有一个多余的空间去存储数据之间的关系
    在同比空间消耗上是比顺序栈大的，但是它不需要提前确定空间的长度
    总的来说，如果数据元素的个数变化较大的时候会选择链栈，这也是选择线性表的数据结构时的一个考量

## 队列(queue)
    队列是只允许在一端进行插入操作在另一端进行删除操作的线性表
> `队头` 删除（出队）
<br> `队尾` 插入（入队、进队）

### 顺序存储结构队列 -- 循环队列
> * 要求把表中的n个元素都存储在数组的前n个单元，这样就造成了出队的时候会将剩下n-1个元素向前移动，导致时间复杂度为O(N)
> * 优化一个点就是，设置 front 表示队头 rear 表示队尾进行操作的话，时间复杂度编程了O(1) 但是在入队出队的过程中，整个队列会整体
往右移动，导致明明存在数组空间，但上溢了 `假溢出`
> * 解决假溢出的办法就是允许队列直接从数组小标最大的位置移动到延续到数组下表最小的位置
> * 又出来一个问题就是队满的条件和队空的条件都是 front = rear，所以会浪费一个空间来使队头区分开来
<br> 满足 `(rear+1)%QueueSize=front` 队满条件，队空依旧是rear = front
<br> `front -> 队头元素的前一位置` `rear -> 队尾元素`
<br> 本质上来说，他是用2个指针，通过求余来进行指针的延续从而达到循环的效果，跟循环链表还是有明显的差别的

### 链接存储结构队列 -- 链队列
    为了使空队列和非空队列的操作一致，链队列也加上头结点，队头指向头结点，队尾指向终端结点，大部分是头插法的方式

## 循环队列与链队列的比较
    基本等同于顺序表与单链表的比较，一种数据结构的不同实现方案嘛


其实对于队列来说实现数据结构的同时要保证线程的开全兴，往往会在外置位添加一个开关标志 switchFlag




