# 查找
## 查找的概述
### 基本概念
<br> `记录[record]` 在查找问题中数据元素的名称
<br> `关键码[key]` 可以标识一个记录的某个数据项
<br> `键值[keyword]` 关键码的值
<br> `主关键码[primary key]` 若关键码可以唯一标识一个记录
<br> `次关键码[second key]`
<br> `查找` 在具有相同类型构成的记录集合中找出满足给定条件的记录 `匹配`
<br> `查找的结果` 若在查找中找到了给定值相匹配的记录，则称查找成功
<br> `静态查找、动态查找` 不涉及删除和插入操作的称为静态查找，若涉及为动态查找
<br> `查找结构 search structure`，本章讨论：
* 线性表：适用于静态查找，主要采用顺序查找技术，折半查找技术
* 树表：适用于动态查找，主要采用二叉排序树的查找技术
* 散列表：静态查找和动态查找均适用，采用散列技术


### 查找算法的性能
<br> 查找算法的性能主要消耗在关键码的比较上，而比较次数除了与算法本身问题规模相关外，还与待查找码在查找集合中的位置有关
<br> 将查找算法进行关键码比较次数的数学期望定义为平均查找长度`average search length`
<br> ASL = ∑<sub>i=1</sub><sup>n</sup>p<sub>i</sub>c<sub>i</sub>
<br> p 为查找记录的概率
<br> c 为查找记录所需的关键码比较次数
## 线性表的查找
### 顺序查找 `sequential search`
<br> 又称线性查找，基本思想：
<br> 从线性表的一端向另一端逐个将关键码与给定值进行比较
#### 顺序表的顺序查找
改进算法：
<br> 设置 ‘哨兵‘,哨兵就是待查值，将它放在查找方向的'尽头'处，免去了在查找过程中每一次比较后都要进行判断查找位置是否越界，从而提高查找速度
<br> 提醒：一切为简化边界条件而引入的附加结点均可称为哨兵
<br> [优化] 许多情况下，查找集合中每个记录的查找概率是不相等的。为了提高查找效率，可以在每个记录中附设一个访问频度域，并使表中的记录始终保持按访问频度非递减的次序排列，使得查找概率大的记录在查找过程中不断向后移，以便在以后的查找技术中减少比较次数，从而提高查找效率
<br> 另外对有序表进行顺序查找，可减少查找失败的平均查找长度，因为不需要遍历整个表就能确定表中不存在要查找的记录
#### 单链表的顺序查找
头指针 -> first
### 折半查找 `binary search` | 折半查找判定树
<br> 要求线性表中的记录必须按关键码有序，并且必须采用顺序存储。一般只能适用于静态查找
#### 折半查找性能分析
<br> 折半查找的过程非常像二叉树的查找过程。通常称这个描述折半查找过程的二叉树为折半查找判定树`biSearch decision tree`，简称判定树
<br> 将折半查找映射成二叉树之后，就能够轻易的去求它的时间复杂度，这就是模型的力量
## 树表的查找技术
在一个无序的顺序表中查找的平均时间复杂度是O(n)，提高查找效率的方法是把记录按照某个关键码进行排序；单链表的查找是无效率的；对于有序的顺序表查找的平均时间复杂度是O(logn),但是插入的平均时间复杂度O(n),有没有一种方法使得查找和插入都能很快地完成呢？
### 二叉排序树 binary sort tree
<br>具有下列性质的二叉树：
<br> 它的左子树不为空，且左子树上所有结点的值都小于根结点
<br> 它的右子树不为空，且右子树上所有结点的值都大于根结点
<br> 它的左右子树都是二叉排序树
<br> 建议：按树的中序遍历会得到一个关键码有序的序列
#### 二叉排序树的插入
<br> 比较值的大小，直到叶子结点然后进行插入
#### 二叉排序树的删除
<br> 分情况(设待删除结点为p，其双亲结点为f，且p是f的左孩子)：
<br> 1、p结点为叶子结点，p既没有左子树也没有右子树
<br> -> f->lchild = null
<br> 2、p只有左子树pL或只有右子树pR
<br> -> f->lchild = pL 或 pR
<br> 3、p既有左子树又有右子树
<br> 有最为简单粗暴的方法，就是将f的做指针指向p的任意一棵子树，然后将另一棵子树重新插入。这将使二叉树的解构发生变化并且增加了高度。
<br> 一个较好的方式就是从某个子树中找出一个结点s，其值能够代替p的值。这个值要满足：在使二叉排序树的解构不发生较大变化的同时保持二叉排序树的特性。这个值应该是大于p的最小值或者小于p的最大值。
f-lchild -> s s->lchild->p->lchild s-rchild->p->rchild sParent-> s->lchild||rchild
### 平衡二叉树 `balance binary tree`
<br> 特性：
<br> 1、跟结点的左子树与右子树深度相差不大于1
<br> 2、左右子树也是平衡二叉树
<br> 平衡因子: 该结点的左子树深度与右子树深度之差
<br> 最小平衡子树： 在平衡二叉树的构建过程中，以距离插入结点最近的、且平衡因子的绝对值大于1的根结点的子树
<br> LL型 RR型    -> LR型 RL型 旋转2次

## 散列表的查找技术
### 概述
所谓查找，实际上就是要确定关键码等于给定值的记录在查找结构中的存储位置。
<br> 采用散列技术将记录存储在一块连续的存储空间中，这块连续的存储空间称为散列表(hash table),将关键码映射为散列表中适当存储位置的函数称为散列函数(hash function),所得的存储位置称为散列地址(hash address)
<br> 若 H(k1) = H(k2) ，则两个不同的记录需要存放在同一个存储位置中，这种现象称为冲突(collision) K1 和 K2 称为同义词(synonym)
### 散列函数的设计
<br> 前言：
<br> 计算简单。散列函数不应该有很大的计算量，否则会降低查找效率
<br> 函数值即散列地址分布均匀。函数值要尽量均匀散步在地址空间，这样才能保证存储空间的有效利用，并减少冲突
<br> 这是是一个世纪矛盾...一般来说散列函数依赖于关键码的分布情况，而在许多应用中并不知道关键码的分布情况
<br> 将不限长的数据集映射成给定长度的数据集，这是散列函数设计的初衷。个人理解上来说像压缩。一对多必然存在冲突，就需要解决冲突方法
<br> 产生冲突是个必然结果，而在设计散列函数的过程中不是要避免冲突而是减少冲突的可能
* 直接定址法  
是关键码的线性函数。即 H(key) = a * key + b
* 除留余数法
选择某个适当的正整数P，以关键码除以p的余数作为散列地址。即 H(key) = key mod p。这里一般要求p小于或等于表长(最好接近m)的最小素数或不包含小于20质因子的合数
* 数字分析法
根据关键码在各个位上的分布情况，选取分布比较均匀的若干位组成散列地址
* 平方取中法
是对关键码平方后，按散列表大小，取中间的若干位作为散列地址(平方后截取)。之所以这样是因为一个数的平方之后中间的几位分布较均匀，不同的关键码较少有相同的平方后截取
* 折叠法
将关键码从左到右分割成位数相等的几部分，最后一部分位数可以短些，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址，通常2中叠加方法：
* * 移位叠加：将各部分的最后一位对齐相加，顺序分割
* * 间界叠加：从一端向另一端沿各部分分界来回叠加后，最后一位对齐相加，S型分割
### 处理冲突的方法
#### 开放地址法 open addressing
用这种方式处理冲突得到的散列表叫做`闭散列表`
<br> 所谓 -> 就是由关键码得到的散列地址一旦产生冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入.
* 线性探测法
当发生冲突时，线性探测法从冲突位置的下一个位置起，依次寻找空的散列地址，即对于键值key，设H(key)=d，闭散列表的长度为m，则发生冲突时，寻找下一个散列地址的公式为： Hi=(H(key)+di)%m (di = 1,2,...,m-1)`这里使用了除留余数法`
<br> 新的问题：-> 某个关键码与其他关键码非同义词，但与那个其他关键码的同义词争夺同一个后继地址，这种在处理冲突的过程中出现的非同义词之间对一个散列地址争夺的现象称为堆积(mass)。显然堆积大大降低了查找效率。
* 二次探测法
Hi = (H(key)+di)%m (di= 1^2,-1^2,2^2,-2^2 ... q^2,-q^2 且 q<=sqrt(m))
* 随机探测法
Hi = (H(key)+di)%m (di = 一个随机序列)
#### 拉链法
用拉链法处理冲突构造的散列表叫做`开散列表`
<br> 将所有散列地址相同的记录，即所有关键码为同义词的记录存储在一个单链表中--称为同义词子表，在散列表中存储的是所有同义词子表的头指针。设n个记录存储在长度为m的开散列表中，则同义词子表的平均长度为N/M
### 散列查找的性能分析
三个因素
<br> 散列函数是否均匀。直接影响产生冲突的概率
<br> 处理冲突的方法。线性探测发会产生堆积，而拉链法不会
<br> 散列表的装填因子。 = 填入表中的记录个数/散列表的长度。散列表的平均查找长度是装填因子 阿尔法 的函数
### 开散列表与闭散列表的比较
这里的比较内容更像是顺序表与单链表的比较，从查找效率和增删效率出发

